import { db } from '../database/supabase';
import { logger } from '../utils/logger';

export class AccountingService {
  
  async generateTaxReportByDateRange(merchantId: string, startDate: string, endDate: string): Promise<string> {
    try {
      const txs = await db.getClient()
        .from('transactions')
        .select('*')
        .eq('merchant_id', merchantId)
        .gte('created_at', startDate)
        .lte('created_at', endDate);

      const conversions = await db.getClient()
        .from('conversions')
        .select('*')
        .in('transaction_id', txs.data?.map((t: any) => t.id) || []);

      return this.formatTaxReport(txs.data || [], conversions.data || [], `${startDate} to ${endDate}`);
    } catch (error) {
      logger.error('Failed to generate tax report', error);
      throw error;
    }
  }

  private formatTaxReport(txs: any[], conversions: any[], period: string): string {
    let csv = 'Date,Description,SOL Amount,USD Value,Conversion USDC,Type,Status,Transaction Hash\n';
    
    txs.forEach(tx => {
      const conversion = conversions.find(c => c.transaction_id === tx.id);
      const date = new Date(tx.created_at).toLocaleDateString();
      const usdValue = (tx.usd_value || 0).toFixed(2);
      const usdcAmount = conversion ? conversion.to_amount.toFixed(2) : '0.00';
      
      csv += `${date},"Payment Received",${tx.amount},${usdValue},${usdcAmount},Income,${tx.status},${tx.signature}\n`;
    });
    
    // Add summary
    const totalSOL = txs.reduce((sum, t) => sum + parseFloat(t.amount), 0);
    const totalUSD = conversions.reduce((sum, c) => sum + parseFloat(c.to_amount || 0), 0);
    
    csv += `\n,,,,,,\n`;
    csv += `Summary for ${period},,,,,,\n`;
    csv += `Total SOL Received,${totalSOL.toFixed(4)},,,,,\n`;
    csv += `Total USD Value,$${totalUSD.toFixed(2)},,,,,\n`;
    csv += `\nGenerated by Solana Payment Autopilot Agent\n`;
    
    return csv;
  }

  async generateMonthlyReport(merchantId: string, month: number, year: number): Promise<any> {
    try {
      const startDate = new Date(year, month - 1, 1);
      const endDate = new Date(year, month, 0);
      
      const txs = await db.getClient()
        .from('transactions')
        .select('*')
        .eq('merchant_id', merchantId)
        .gte('created_at', startDate.toISOString())
        .lte('created_at', endDate.toISOString());

      const conversions = await db.getClient()
        .from('conversions')
        .select('*')
        .in('transaction_id', txs.data?.map((t: any) => t.id) || []);

      return {
        month,
        year,
        transactionCount: txs.data?.length || 0,
        totalSOL: txs.data?.reduce((sum: number, t: any) => sum + parseFloat(t.amount), 0) || 0,
        totalUSDC: conversions.data?.reduce((sum: number, c: any) => sum + parseFloat(c.to_amount || 0), 0) || 0,
        avgTransactionSize: txs.data && txs.data.length > 0 
          ? txs.data.reduce((sum: number, t: any) => sum + parseFloat(t.amount), 0) / txs.data.length 
          : 0
      };
    } catch (error) {
      logger.error('Failed to generate monthly report', error);
      throw error;
    }
  }
}

export const accountingService = new AccountingService();
